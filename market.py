import numpy as np
import datetime

from exchange_extended import Exchange, OrderSide, Order
import orderbook_final

# TODO: remove matplotlib
import matplotlib.pyplot as plt
# np.random.seed(0)


# constants:
MAX_LEVEL = 5
# all orders generated by trader_id=0 are created by the order generator
ORDER_GENERATOR_TRADER = 0


class MarketInterface:
    def __init__(self) -> None:
        pass

    def initialize_lob(self, exchange: Exchange, time: datetime.datetime) -> np.ndarray:
        pass

    def simulate_n_seconds(self, X: np.ndarray, exchange: Exchange, time: datetime.datetime, n: float) -> np.ndarray:
        pass

    def simulate_n_seconds(self, X: np.ndarray, exchange: Exchange, time: datetime.datetime, n: int) -> np.ndarray:
        pass

    def matched_order_notification():
        pass



class MarketPoissonProcesses(MarketInterface):

    def __init__(self) -> None:
        self.p_b = None
        self.p_a = None
        self.last_p_b = None
        self.last_p_a = None

        self.lmbda = [0, 1.85, 1.51, 1.09, 0.88, 0.77]
        self.theta = [0, 0.71, 0.81, 0.68, 0.56, 0.47]
        self.mu = 0.94

        # orders:   order_id -> Order
        self.orders = {}
        # prices:   price -> [order_id, ...]
        self.prices = {}


    def __get_bid_price(self, X: np.ndarray) -> int:
        bids = np.where(X<0)[0]
        if len(bids) > 0:
            return bids[-1]
        return None # if the Limit Order Book is empty on the buy side
    

    def __get_ask_price(self, X: np.ndarray) -> int:
        asks = np.where(X>0)[0]
        if len(asks) > 0:
            return asks[0]
        return None # if the Limit Order Book is empty on the sell side
    

    def __get_rates(self, X: np.ndarray) -> list:

        p_b = self.p_b
        p_a = self.p_a
        if p_b == None:
            p_b = self.last_p_b
        if p_a == None:
            p_a = self.last_p_a

        rates = []

        # limit buy orders
        for i in range(1, MAX_LEVEL + 1):
            price = p_a - i
            rate = self.lmbda[i]
            rates.append(('limit_buy_order', price, rate))
        
        # limit sell orders
        for i in range(1, MAX_LEVEL + 1):
            price = p_b + i
            rate = self.lmbda[i]
            rates.append(('limit_sell_order', price, rate))
        
        rate = self.mu
        # market buy order
        rates.append(('market_buy_order', p_a, rate))

        # market sell order
        rates.append(('market_sell_order', p_b, rate))

        # cancel buy orders
        for i in range(1, MAX_LEVEL + 1):
            price = p_a - i
            rate = self.theta[i] * abs(X[price])
            rates.append(('cancel_buy_order', price, rate))
        
        # cancel sell orders
        for i in range(1, MAX_LEVEL + 1):
            price = p_b + i
            rate = self.theta[i] * abs(X[price])
            rates.append(('cancel_sell_order', price, rate))
        
        return rates
    

    def __get_rates_sum(self, rates: list) -> float:
        RATE = 2 # index of the rate in the tuple

        rates_sum = sum(map(lambda x: x[RATE], rates))
        return rates_sum


    def __get_random_event(self, rates: list, sum_rates: float) -> tuple[str, int]:
        EVENT, PRICE, RATE = 0, 1, 2 # indices of the event, price and rate in the tuple

        random_choice = np.random.uniform(0, sum_rates)
        i = 0
        current_sum = rates[i][RATE]
        while current_sum <= random_choice:
            i += 1
            current_sum += rates[i][RATE]
        event, price = rates[i][EVENT], rates[i][PRICE]
        return event, price
    

    def initialize_lob(self, exchange: Exchange, time: datetime.datetime) -> np.ndarray:
        # TODO: replace with exchange_max_price
        X = np.zeros(1001)

        # TODO: price to index conversion
        buy_prices = [223, 222, 221, 220, 219]
        sell_prices = [224, 225, 226, 227, 228]
        buy_volumes = [200, 100, 5, 10, 250]
        sell_volumes = [287, 77, 100, 10, 2]
        avg_order_size = 50
        levels = len(buy_prices)

        for i in range(levels):
            self.prices[buy_prices[i]] = []
            for _ in range(buy_volumes[i] // avg_order_size):
                price = buy_prices[i]
                X[price] -= 1
                order = Order(OrderSide.BUY, price, 1, time, ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                self.orders[order_id] = order
                self.prices[price].append(order_id)

            self.prices[sell_prices[i]] = []
            for _ in range(sell_volumes[i] // avg_order_size):
                price = sell_prices[i]
                X[price] += 1
                order = Order(OrderSide.SELL, price, 1, time, ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                self.orders[order_id] = order
                self.prices[price].append(order_id)
        
        return X
    

    def simulate_n_seconds(self, X: np.ndarray, exchange: Exchange, time: datetime.datetime, n: float) -> np.ndarray:
        
        self.p_b = self.__get_bid_price(X)
        self.p_a = self.__get_ask_price(X)
        rates = self.__get_rates(X)
        self.last_p_b = self.p_b
        self.last_p_a = self.p_a
        sum_rates = self.__get_rates_sum(rates)

        simulation_time = 0
        delta_t = np.random.exponential(1.0 / sum_rates)
        simulation_time += delta_t
        
        mid_prices = []
        while simulation_time <= n: # n seconds

            # TODO: delete
            if self.p_b != exchange.buy_side.best_price or self.p_a != exchange.sell_side.best_price:
                raise Exception("Invalid best price!")
            
            # TODO: replace 1000 with exchange_max_price
            if (self.p_b != None and self.p_b + MAX_LEVEL >= 1000) or (self.p_a != None and self.p_a - MAX_LEVEL <= 0):
                raise Exception("Price levels are out of range!")

            event, price = self.__get_random_event(rates, sum_rates)

            if event == 'limit_buy_order':
                X[price] -= 1

                order = Order(OrderSide.BUY, price, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                
                self.orders[order_id] = order
                if price in self.prices:
                    self.prices[price].append(order_id)
                else:
                    self.prices[price] = [order_id]
            elif event == 'limit_sell_order':
                X[price] += 1

                order = Order(OrderSide.SELL, price, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                self.orders[order_id] = order
                if price in self.prices:
                    self.prices[price].append(order_id)
                else:
                    self.prices[price] = [order_id]
            elif event == 'market_buy_order' and self.p_a != None:
                # TODO: delete
                if X[self.p_a] <= 0:
                    print(X[self.p_a], self.p_b, self.p_a)
                    print(X)
                    print(self.__get_bid_price(X), self.__get_ask_price(X))
                    raise Exception("Invalid market buy order: X[p_a] <= 0")
                X[self.p_a] -= 1

                order = Order(OrderSide.BUY, self.p_a, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                counterparty_id, order_id = exchange.add_market_order(order)

                if counterparty_id == ORDER_GENERATOR_TRADER:
                    order = self.orders[order_id]
                    price = order.price
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'market_sell_order' and self.p_b != None:
                # TODO: delete
                if X[self.p_b] >= 0:
                    print(X[self.p_b], self.p_b, self.p_a)
                    print(X)
                    print(self.__get_bid_price(X), self.__get_ask_price(X))
                    raise Exception("Invalid market sell order: X[p_b] >= 0")
                X[self.p_b] += 1

                order = Order(OrderSide.SELL, self.p_b, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                counterparty_id, order_id = exchange.add_market_order(order)

                if counterparty_id == ORDER_GENERATOR_TRADER:
                    order = self.orders[order_id]
                    price = order.price
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'cancel_buy_order':
                if self.p_b == None:
                    raise Exception("There are no buy orders: invalid cancel order!")
                
                if len(self.prices[price]) != 0:
                    X[price] += 1

                    # TODO: delete
                    if price > self.p_b:
                        raise Exception("Invalid cancel order: price > p_b")

                    random_order_id = self.prices[price][np.random.randint(len(self.prices[price]))]
                    order_id = random_order_id
                    trader_id = ORDER_GENERATOR_TRADER

                    # TODO: delete
                    if self.orders[order_id].side != OrderSide.BUY:
                        # print(self.orders[order_id].side)
                        # for order_id in self.prices[price]:
                        #     print(self.orders[order_id].side)
                        raise Exception("Invalid cancel buy order!")

                    exchange.cancel_order(order_id, trader_id)
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'cancel_sell_order':
                if self.p_a == None:
                    raise Exception("There are no sell orders: invalid cancel order!")
                
                if len(self.prices[price]) != 0:
                    X[price] -= 1

                    # TODO: delete
                    if price < self.p_a:
                        raise Exception("Invalid cancel order: price < p_a")

                    random_order_id = self.prices[price][np.random.randint(len(self.prices[price]))]
                    order_id = random_order_id
                    trader_id = ORDER_GENERATOR_TRADER

                    # TODO: delete
                    if self.orders[order_id].side != OrderSide.SELL:
                        # print(self.orders[order_id].side, order_id)
                        # for order_id in self.prices[price]:
                        #     print(self.orders[order_id].side)
                        raise Exception("Invalid cancel sell order!")

                    exchange.cancel_order(order_id, trader_id)
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            
            if self.p_b != None and self.p_a != None:
                mid_prices.append((self.p_b + self.p_a) / 2)

            self.p_b = self.__get_bid_price(X)
            self.p_a = self.__get_ask_price(X)
            rates = self.__get_rates(X)
            if self.p_b != None:
                self.last_p_b = self.p_b
            if self.p_a != None:
                self.last_p_a = self.p_a
            sum_rates = self.__get_rates_sum(rates)

            delta_t = np.random.exponential(1 / sum_rates)
            simulation_time += delta_t
        
        plt.plot(mid_prices)
        plt.show()

        return X
    

    def simulate_n_events(self, X: np.ndarray, exchange: Exchange, time: datetime.datetime, n: int) -> tuple[np.ndarray, datetime.datetime]:
        
        simulation_time = 0
        
        mid_prices = []
        for _ in range(n): # n events

            self.p_b = self.__get_bid_price(X)
            self.p_a = self.__get_ask_price(X)
            rates = self.__get_rates(X)
            if self.p_b != None:
                self.last_p_b = self.p_b
            if self.p_a != None:
                self.last_p_a = self.p_a
            sum_rates = self.__get_rates_sum(rates)

            # TODO: delete
            if self.p_b != exchange.buy_side.best_price or self.p_a != exchange.sell_side.best_price:
                raise Exception("Invalid best price!")
            
            # TODO: replace 1000 with exchange_max_price
            if (self.p_b != None and self.p_b + MAX_LEVEL >= 1000) or (self.p_a != None and self.p_a - MAX_LEVEL <= 0):
                raise Exception("Price levels are out of range!")

            event, price = self.__get_random_event(rates, sum_rates)

            if event == 'limit_buy_order':
                X[price] -= 1

                order = Order(OrderSide.BUY, price, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                
                self.orders[order_id] = order
                if price in self.prices:
                    self.prices[price].append(order_id)
                else:
                    self.prices[price] = [order_id]
            elif event == 'limit_sell_order':
                X[price] += 1

                order = Order(OrderSide.SELL, price, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                order_id = exchange.add_limit_order(order)
                self.orders[order_id] = order
                if price in self.prices:
                    self.prices[price].append(order_id)
                else:
                    self.prices[price] = [order_id]
            elif event == 'market_buy_order' and self.p_a != None:
                # TODO: delete
                if X[self.p_a] <= 0:
                    print(X[self.p_a], self.p_b, self.p_a)
                    print(X)
                    print(self.__get_bid_price(X), self.__get_ask_price(X))
                    raise Exception("Invalid market buy order: X[p_a] <= 0")
                X[self.p_a] -= 1

                order = Order(OrderSide.BUY, self.p_a, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                counterparty_id, order_id = exchange.add_market_order(order)

                if counterparty_id == ORDER_GENERATOR_TRADER:
                    order = self.orders[order_id]
                    price = order.price
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'market_sell_order' and self.p_b != None:
                # TODO: delete
                if X[self.p_b] >= 0:
                    print(X[self.p_b], self.p_b, self.p_a)
                    print(X)
                    print(self.__get_bid_price(X), self.__get_ask_price(X))
                    raise Exception("Invalid market sell order: X[p_b] >= 0")
                X[self.p_b] += 1

                order = Order(OrderSide.SELL, self.p_b, 1, time + datetime.timedelta(seconds=simulation_time), ORDER_GENERATOR_TRADER)
                counterparty_id, order_id = exchange.add_market_order(order)

                if counterparty_id == ORDER_GENERATOR_TRADER:
                    order = self.orders[order_id]
                    price = order.price
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'cancel_buy_order':
                if self.p_b == None:
                    raise Exception("There are no buy orders: invalid cancel order!")
                
                if len(self.prices[price]) != 0:
                    X[price] += 1

                    # TODO: delete
                    if price > self.p_b:
                        raise Exception("Invalid cancel order: price > p_b")

                    random_order_id = self.prices[price][np.random.randint(len(self.prices[price]))]
                    order_id = random_order_id
                    trader_id = ORDER_GENERATOR_TRADER

                    # TODO: delete
                    if self.orders[order_id].side != OrderSide.BUY:
                        # print(self.orders[order_id].side)
                        # for order_id in self.prices[price]:
                        #     print(self.orders[order_id].side)
                        raise Exception("Invalid cancel buy order!")

                    exchange.cancel_order(order_id, trader_id)
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            elif event == 'cancel_sell_order':
                if self.p_a == None:
                    raise Exception("There are no sell orders: invalid cancel order!")
                
                if len(self.prices[price]) != 0:
                    X[price] -= 1

                    # TODO: delete
                    if price < self.p_a:
                        raise Exception("Invalid cancel order: price < p_a")

                    random_order_id = self.prices[price][np.random.randint(len(self.prices[price]))]
                    order_id = random_order_id
                    trader_id = ORDER_GENERATOR_TRADER

                    # TODO: delete
                    if self.orders[order_id].side != OrderSide.SELL:
                        # print(self.orders[order_id].side, order_id)
                        # for order_id in self.prices[price]:
                        #     print(self.orders[order_id].side)
                        raise Exception("Invalid cancel sell order!")

                    exchange.cancel_order(order_id, trader_id)
                    self.orders.pop(order_id)
                    self.prices[price].remove(order_id)
            
            if self.p_b != None and self.p_a != None:
                mid_prices.append((self.p_b + self.p_a) / 2)

            delta_t = np.random.exponential(1 / sum_rates)
            simulation_time += delta_t
        
        plt.plot(mid_prices)
        plt.show()

        return X, simulation_time


    def matched_order_notification(self, order_id: int):
        order = self.orders[order_id]
        price = order.price
        self.orders.pop(order_id)
        self.prices[price].remove(order_id)
    




if __name__ == '__main__':
    buy_side = orderbook_final.OrderBookSide(OrderSide.BUY)
    sell_side = orderbook_final.OrderBookSide(OrderSide.SELL)
    exchange = Exchange(buy_side, sell_side)
    
    market = MarketPoissonProcesses()
    time = datetime.datetime.now()
    X = market.initialize_lob(exchange, time)
    X = market.simulate_n_seconds(X, exchange, time, 1000)
    # X, simulation_time = market.simulate_n_events(X, exchange, time, 1000)
    # print(list(X)[:500])
    # print(simulation_time)